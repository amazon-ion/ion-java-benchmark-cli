package com.amazon.ion.benchmark;

import com.amazon.ion.IonDatagram;
import com.amazon.ion.IonDecimal;
import com.amazon.ion.IonFloat;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonStruct;
import com.amazon.ion.IonSystem;
import com.amazon.ion.IonType;
import com.amazon.ion.IonValue;
import com.amazon.ion.system.IonReaderBuilder;
import com.amazon.ion.system.IonSystemBuilder;
import com.amazon.ion.util.IonStreamUtils;
import com.amazon.ionschema.IonSchemaSystem;
import com.amazon.ionschema.Schema;
import com.amazon.ionschema.Type;
import com.amazon.ionschema.Violations;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.junit.After;
import org.junit.Test;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

public class DataGeneratorTest {
    private static String outputFile = null;
    private final static IonSystem SYSTEM = IonSystemBuilder.standard().build();
    private final static String INPUT_ION_STRUCT_FILE_PATH = "./tst/com/amazon/ion/benchmark/testStruct.isl";
    private final static String INPUT_ION_LIST_FILE_PATH = "./tst/com/amazon/ion/benchmark/testList.isl";
    private final static String INPUT_NESTED_ION_LIST_PATH = "./tst/com/amazon/ion/benchmark/testNestedList.isl";
    private final static String INPUT_NESTED_ION_STRUCT_PATH = "./tst/com/amazon/ion/benchmark/testNestedStruct.isl";
    private final static String INPUT_ION_DECIMAL_FILE_PATH = "./tst/com/amazon/ion/benchmark/testDecimal.isl";
    private final static String INPUT_ION_TIMESTAMP_FILE_PATH = "./tst/com/amazon/ion/benchmark/testTimestamp.isl";
    private final static String INPUT_ION_CLOB_FILE_PATH = "./tst/com/amazon/ion/benchmark/testClob.isl";
    private final static String INPUT_ION_BLOB_FILE_PATH = "./tst/com/amazon/ion/benchmark/testBlob.isl";
    private final static String INPUT_ION_FLOAT_FILE_PATH = "./tst/com/amazon/ion/benchmark/testFloat.isl";
    private final static String INPUT_ION_FLOAT_VALID_VALUE_FILE_PATH = "./tst/com/amazon/ion/benchmark/testFloatValidValue.isl";
    private final static String INPUT_ION_SYMBOL_FILE_PATH = "./tst/com/amazon/ion/benchmark/testSymbol.isl";
    private final static String INPUT_ION_STRING_FILE_PATH = "./tst/com/amazon/ion/benchmark/testString.isl";
    private final static String INPUT_ION_INT_FILE_PATH = "./tst/com/amazon/ion/benchmark/testInt.isl";
    private final static String SCORE_DIFFERENCE = "scoreDifference";
    private final static String COMPARISON_REPORT_WITHOUT_REGRESSION = "./tst/com/amazon/ion/benchmark/testComparisonReportWithoutRegression.ion";
    private final static String COMPARISON_REPORT = "./tst/com/amazon/ion/benchmark/testComparisonReport.ion";
    private final static String BENCHMARK_RESULT_PREVIOUS = "./tst/com/amazon/ion/benchmark/IonLoaderBenchmarkResultPrevious.ion";
    private final static String BENCHMARK_RESULT_NEW = "./tst/com/amazon/ion/benchmark/IonLoaderBenchmarkResultNew.ion";
    private final static BigDecimal EXPECTED_GC_ALLOCATE_THRESHOLD = new BigDecimal("-0.010774139119162");
    private final static BigDecimal EXPECTED_SPEED_THRESHOLD = new BigDecimal("-0.326936");
    private final static BigDecimal EXPECTED_HEAP_USAGE_THRESHOLD = new BigDecimal("-0.184482");
    private final static BigDecimal EXPECTED_SERIALIZED_SIZE = new BigDecimal("0.000000");
    private final static String GC_ALLOCATE = "路gc.alloc.rate";
    private final static String HEAP_USAGE = "Heap usage";
    private final static String SERIALIZED_SIZE = "Serialized size";
    private final static String SPEED = "speed";

    /**
     * Construct IonReader for current output file in order to finish the following test process.
     * @param optionsMap is the hash map which generated by the command line parser which match the option name and its value appropriately.
     * @return constructed IonReader.
     * @throws Exception if errors occur during executing data generator process.
     */
    public static IonReader executeAndRead(Map<String, Object> optionsMap) throws Exception {
        outputFile = optionsMap.get("<output_file>").toString();
        GeneratorOptions.executeGenerator(optionsMap);
        return IonReaderBuilder.standard().build(new BufferedInputStream(new FileInputStream(outputFile)));
    }

    /**
     * Detect if violation occurs by comparing every single data in the generated file with Ion Schema constraints.
     * @param inputFile is the Ion Schema file.
     * @throws Exception if error occurs when checking if there is violation in the generated data.
     */
    public static void violationDetect(String inputFile) throws Exception {
        Map <String, Object> optionsMap = Main.parseArguments("generate", "--data-size", "5000", "--format", "ion_text", "--input-ion-schema", inputFile, "test8.ion");
        String inputFilePath = optionsMap.get("--input-ion-schema").toString();
        outputFile = optionsMap.get("<output_file>").toString();
        String schemaID = inputFile.substring(inputFile.lastIndexOf('/') + 1);
        try (
                IonReader readerInput = IonReaderBuilder.standard().build(new BufferedInputStream(new FileInputStream(inputFilePath)));
                IonReader reader = DataGeneratorTest.executeAndRead(optionsMap);
        ) {
            // Get the name of Ion Schema.
            IonDatagram schema = ReadGeneralConstraints.LOADER.load(readerInput);
            String ionSchemaName = null;
            for (int i = 0; i < schema.size(); i++) {
                IonValue schemaValue = schema.get(i);
                if (schemaValue.getType().equals(IonType.STRUCT) && schemaValue.getTypeAnnotations()[0].equals(IonSchemaUtilities.KEYWORD_TYPE)) {
                    IonStruct constraintStruct = (IonStruct) schemaValue;
                    ionSchemaName = constraintStruct.get(IonSchemaUtilities.KEYWORD_NAME).toString();
                    break;
                }
            }
            //Load schema file and get the type of the Ion Schema.
            IonSchemaSystem ISS = IonSchemaUtilities.buildIonSchemaSystem(inputFile);
            Schema newSchema = ISS.loadSchema(schemaID);
            Type type = newSchema.getType(ionSchemaName);
            while (reader.next() != null) {
                IonValue value = SYSTEM.newValue(reader);
                Violations violations = type.validate(value);
                assertTrue("Violations " + violations + "found in value " + value, violations.isValid());
            }
        }
    }

    /**
     * Assert the format of generated file is conform with the expected format [ion_binary|ion_text].
     * @throws Exception if error occurs when executing Ion data generator.
     */
    @Test
    public void testGeneratedFormat() throws Exception {
        List<String> inputs = new ArrayList<>(Arrays.asList("ion_text","ion_binary"));
        for (int i = 0; i < 2; i++ ) {
            Map<String, Object> optionsMap = Main.parseArguments("generate", "--data-size", "5000", "--format", "ion_text", "--input-ion-schema", INPUT_ION_DECIMAL_FILE_PATH, "test8.ion");
            GeneratorOptions.executeGenerator(optionsMap);
            String format = ((List<String>)optionsMap.get("--format")).get(0);
            outputFile = optionsMap.get("<output_file>").toString();
            Path path = Paths.get(outputFile);
            byte[] buffer = Files.readAllBytes(path);
            assertEquals(Format.valueOf(format.toUpperCase()) == Format.ION_BINARY, IonStreamUtils.isIonBinary(buffer));
        }
    }

    /**
     * Assert the generated data size in bytes has an 10% difference with the expected size, this range is not available for Ion symbol, because the size of symbol is predicted.
     * @throws Exception if error occurs when executing Ion data generator.
     */
    @Test
    public void testSizeOfGeneratedData() throws Exception {
        Map<String, Object> optionsMap = Main.parseArguments("generate", "--data-size", "5000", "--format", "ion_text", "--input-ion-schema", INPUT_ION_TIMESTAMP_FILE_PATH, "test8.ion");
        GeneratorOptions.executeGenerator(optionsMap);
        int expectedSize = Integer.parseInt(optionsMap.get("--data-size").toString());
        outputFile = optionsMap.get("<output_file>").toString();
        Path filePath = Paths.get(outputFile);
        FileChannel fileChannel;
        fileChannel = FileChannel.open(filePath);
        int fileSize = (int)fileChannel.size();
        fileChannel.close();
        int difference = Math.abs(expectedSize - fileSize);
        assertTrue(difference <= 0.1 * expectedSize);
    }

    /**
     * Test if there's violation when generating Ion Struct based on Ion Schema.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfIonStruct() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_STRUCT_FILE_PATH);
    }

    /**
     * Test if there's violation when generating Ion List based on Ion Schema.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfIonList() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_LIST_FILE_PATH);
    }

    /**
     * Test if there's violation when generating nested IonStruct based on Ion Schema.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfNestedIonStruct() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_NESTED_ION_STRUCT_PATH);
    }

    /**
     * Test if there's violation when generating nested Ion Struct based on Ion Schema.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfNestedIonList() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_NESTED_ION_LIST_PATH);
    }

    /**
     * Test if there's violation when generating Ion Timestamp based on Ion Schema.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfTimestamp() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_TIMESTAMP_FILE_PATH);
    }

    /**
     * Test if there's violation when generating decimals based on Ion Schema.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfIonDecimal() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_DECIMAL_FILE_PATH);
    }

    /**
     * Test if there's violation when generating clobs based on Ion Schema.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfIonClob() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_CLOB_FILE_PATH);
    }

    /**
     * Test if there's violation when generating blobs based on Ion Schema.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfIonBlob() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_BLOB_FILE_PATH);
    }

    /**
     * Test if there's violation when generating floats from Ion Schema file.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfFloat() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_FLOAT_FILE_PATH);
    }

    /**
     * Test if there's violation when generating symbols from Ion Schema file.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfSymbol() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_SYMBOL_FILE_PATH);
    }

    /**
     * Test if there's violation when generating strings from Ion Schema file.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfString() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_STRING_FILE_PATH);
    }

    /**
     * Test if there's violation when generating floats from Ion Schema file which specifies valid value.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfFloatValidValue() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_FLOAT_VALID_VALUE_FILE_PATH);
    }

    /**
     * Test if there's violation when generating int from Ion Schema file which specifies valid value range.
     * @throws Exception if error occurs during the violation detecting process.
     */
    @Test
    public void testViolationOfIntValidValue() throws Exception {
        DataGeneratorTest.violationDetect(INPUT_ION_INT_FILE_PATH);
    }

    /**
     * Test the accuracy of the calculated results in the generated file.
     * @throws Exception if error occurs when reading the input file.
     */
    @Test
    public void testParseBenchmark() throws Exception {
        Map<String, Object> optionsMap = Main.parseArguments("compare", "--benchmark-result-previous", BENCHMARK_RESULT_PREVIOUS, "--benchmark-result-new", BENCHMARK_RESULT_NEW, "test11.ion");
        ParseAndCompareBenchmarkResults.compareResult(optionsMap);
        outputFile = optionsMap.get("<output_file>").toString();
        try (IonReader reader = IonReaderBuilder.standard().build(new BufferedInputStream(new FileInputStream(outputFile)))) {
            reader.next();
            reader.stepIn();
            while (reader.next() != null) {
                if (reader.getFieldName().equals(SCORE_DIFFERENCE)) {
                    reader.stepIn();
                    while (reader.next() != null) {
                        String benchmarkResultPrevious = optionsMap.get("--benchmark-result-previous").toString();
                        String benchmarkResultNew = optionsMap.get("--benchmark-result-new").toString();
                        BigDecimal previousScore = ParseAndCompareBenchmarkResults.getScore(benchmarkResultPrevious, reader.getFieldName());
                        BigDecimal newScore = ParseAndCompareBenchmarkResults.getScore(benchmarkResultNew, reader.getFieldName());
                        BigDecimal scoreDifference = newScore.subtract(previousScore);
                        BigDecimal relativeDifference = scoreDifference.divide(previousScore, RoundingMode.HALF_UP);
                        assertTrue(relativeDifference.equals(reader.decimalValue()));
                    }
                    reader.stepOut();
                }
            }
        }
    }

    /**
     * Test whether the method which calculate and construct threshold map can return the expected result.
     * @throws Exception if errors occur when constructing threshold map.
     */
    @Test
    public void testThresholdMapParser() throws Exception {
        Map<String, BigDecimal> thresholdMap = ParseAndCompareBenchmarkResults.getThresholdMap(BENCHMARK_RESULT_PREVIOUS, BENCHMARK_RESULT_NEW);
        for (String keyWord : thresholdMap.keySet()) {
            switch (keyWord) {
                case GC_ALLOCATE:
                    assertTrue(thresholdMap.get(keyWord).equals(EXPECTED_GC_ALLOCATE_THRESHOLD));
                    break;
                case SPEED:
                    assertTrue(thresholdMap.get(keyWord).equals(EXPECTED_SPEED_THRESHOLD));
                    break;
                case HEAP_USAGE:
                    assertTrue(thresholdMap.get(keyWord).equals(EXPECTED_HEAP_USAGE_THRESHOLD));
                    break;
                case SERIALIZED_SIZE:
                    assertTrue(thresholdMap.get(keyWord).equals(EXPECTED_SERIALIZED_SIZE));
                    break;
                default:
                    throw new IllegalStateException("This aspect of benchmark result is not supported when generating threshold map.");
            }
        }
    }

    /**
     * Test whether the detecting regression process can return the expected result when there is performance regression in the test file.
     * In this unit test we use an Ion file which contain regression on [路gc.alloc.rate] as input to test the detectRegression method.
     * @throws Exception if error occur when reading Ion data.
     */
    @Test
    public void testRegressionDetected() throws Exception {
        Map<String, BigDecimal> scoreMap = constructScoreMap(COMPARISON_REPORT);
        Map<String, BigDecimal> thresholdMap = ParseAndCompareBenchmarkResults.getThresholdMap(BENCHMARK_RESULT_PREVIOUS, BENCHMARK_RESULT_NEW);
        String detectionResult = ParseAndCompareBenchmarkResults.detectRegression(thresholdMap, scoreMap, COMPARISON_REPORT);
        assertEquals("The performance regression detected when benchmark the ion-java from the new commit with the test data: testList.10n and parameters: read::{format:\"ION_BINARY\",type:\"FILE\",api:\"DOM\"}\n" +
                "The following aspects have regressions: {路gc.alloc.rate=-0.2851051607559}\n", detectionResult);
    }

    /**
     * Test whether the detecting regression process can return the expected result when there is no performance regression in the test file.
     * In this unit test we use an Ion file which contain regression on [路gc.alloc.rate] as input to test the detectRegression method.
     * @throws Exception if error occur when reading Ion data.
     */
    @Test
    public void testRegressionNotDetected() throws Exception {
        Map<String, BigDecimal> scoreMap = constructScoreMap(COMPARISON_REPORT_WITHOUT_REGRESSION);
        Map<String, BigDecimal> thresholdMap = ParseAndCompareBenchmarkResults.getThresholdMap(BENCHMARK_RESULT_PREVIOUS, BENCHMARK_RESULT_NEW);
        String detectionResult = ParseAndCompareBenchmarkResults.detectRegression(thresholdMap, scoreMap, COMPARISON_REPORT_WITHOUT_REGRESSION);
        assertNull(detectionResult);
    }

    /**
     * Construct the score map which matches the benchmark aspect with its score from the comparison report.
     * @param inputFile specify the path of comparison report which is generated after the comparing benchmark results from different commits.
     * @return a Map<String, BigDecimal> contains scores information.
     * @throws Exception if error occurs when reading data.
     */
    private static Map<String, BigDecimal> constructScoreMap(String inputFile) throws Exception {
        Map<String, BigDecimal> scoreMap = new HashMap<>();
        IonStruct scoresStruct;
        try (IonReader reader = IonReaderBuilder.standard().build(new BufferedInputStream(new FileInputStream(inputFile)))) {
            reader.next();
            if (reader.getType().equals(IonType.STRUCT)) {
                IonStruct comparisonResult = (IonStruct) ReadGeneralConstraints.LOADER.load(reader).get(0);
                scoresStruct = (IonStruct) comparisonResult.get(ParseAndCompareBenchmarkResults.RELATIVE_DIFFERENCE_SCORE);
            } else {
                throw new IllegalStateException("The data structure of the comparison report is not supported.");
            }
        }
        for (String keyWord : ParseAndCompareBenchmarkResults.BENCHMARK_SCORE_KEYWORDS) {
            IonValue score = scoresStruct.get(keyWord);
            if (score.getType().equals(IonType.FLOAT)) {
                IonFloat scoreFloat = (IonFloat) score;
                scoreMap.put(keyWord, scoreFloat.bigDecimalValue());
            } else {
                IonDecimal scoreDecimal = (IonDecimal) score;
                scoreMap.put(keyWord, scoreDecimal.bigDecimalValue());
            }
        }
        return scoreMap;
    }

    /**
     * Delete all files generated in the test process.
     * @throws IOException if an error occur when deleting files.
     */
    @After
    public void deleteGeneratedFile() throws IOException {
        if (outputFile != null) {
            Path filePath = Paths.get(outputFile);
            if(Files.exists(filePath)) {
                Files.delete(filePath);
            }
        }
    }
}
