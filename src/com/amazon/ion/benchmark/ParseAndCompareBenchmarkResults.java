package com.amazon.ion.benchmark;

import com.amazon.ion.IonDatagram;
import com.amazon.ion.IonList;
import com.amazon.ion.IonLoader;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonStruct;
import com.amazon.ion.IonType;
import com.amazon.ion.system.IonReaderBuilder;
import com.amazon.ion.system.IonSystemBuilder;
import org.apache.commons.math3.stat.StatUtils;
import org.apache.commons.math3.stat.descriptive.rank.Percentile;
import org.apache.commons.math3.stat.inference.TTest;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.DoubleStream;

public class ParseAndCompareBenchmarkResults {
    public static final List<String> BENCHMARK_SCORE_KEYWORDS = Arrays.asList("speed", "Heap usage", "Serialized size", "Â·gc.alloc.rate");
    private static final String PRIMARY_METRIC = "primaryMetric";
    private static final String SECONDARY_METRIC = "secondaryMetrics";
    private static final String SPEED = "speed";
    private static final String RAW_DATA = "rawData";
    private static final IonLoader LOADER = IonSystemBuilder.standard().build().newLoader();

    /**
     * Get the paths of benchmark results from two commits then invoke the methods to calculate relative change for each aspect from the result.
     *
     * @param optionsMap is the hash map which generated by the command line parser which match the option name and its value appropriately.
     * @throws Exception if errors occur when reading Ion data.
     */
    public static void compareResult(Map<String, Object> optionsMap) throws Exception {
        String benchmarkResultPrevious = optionsMap.get("--benchmark-result-previous").toString();
        String benchmarkResultNew = optionsMap.get("--benchmark-result-new").toString();
        Map<String, Double> comparisonResults = new HashMap<>();
        for (String benchmarkScoreKeyword : BENCHMARK_SCORE_KEYWORDS) {
            double[] previousData = preProcess(benchmarkResultPrevious, benchmarkScoreKeyword);
            double[] newData = preProcess(benchmarkResultNew, benchmarkScoreKeyword);
            double comparisonResult = detectRegression(previousData, newData);
            if (comparisonResult > 0) {
                comparisonResults.put(benchmarkScoreKeyword, comparisonResult);
            }
        }
        System.out.println(comparisonSummary(comparisonResults));
    }

    /**
     * This method composes the results of the performance regression detection.
     * @param result represents the metrics which have regressions and their regression values.
     * @return the composed regression detection summary.
     */
    private static String comparisonSummary(Map<String, Double> result) {
        StringBuilder summary = new StringBuilder();
        for (Map.Entry<String, Double> comparisonResult : result.entrySet()) {
            summary.append(String.format("There is %.2f%% regression on %s.\n", comparisonResult.getValue() * 100, comparisonResult.getKey()));
        }
        return summary.toString();
    }

    /**
     * This method uses two-sample T-test method to detect performance regression.
     * @param before represents the benchmark results from benchmarking the previous ion-java.
     * @param after represents the benchmark results from benchmarking the ion-java with the new changes.
     * @return regression detection result. If the regression is detected, then the regression value will be returned, else 0 will be returned.
     */
    public static double detectRegression(double[] before, double[] after) {
        TTest tTest = new TTest();
        // Perform two-sample t-test
        double pValue = tTest.tTest(before, after);
        // Calculate means of both datasets
        double meanBefore = StatUtils.mean(before);
        double meanAfter = StatUtils.mean(after);
        // Calculate the difference in means (regression value)
        double regressionValue = (meanAfter - meanBefore) / meanBefore;
        // Two-sample T-test is a hypothesis test used to compare the means of two independent groups.
        // Null hypothesis states that there is no difference between two groups.
        // P-value represents the probability of null hypothesis is true.
        // Threshold value 0.05 is a common convention. We might adjust the value if we'd like to reduce the false positives/negatives.
        // If the calculated p-value is greater than 0.05, then the result failed to reject the null hypothesis which means there isn't enough statistical evidence to say two groups are different.
        // If the p-value is smaller than 0.05, then the result is considered statistically significant and the null hypothesis would be rejected. There is strong evidence that two groups of sample data are different.
        if (pValue < 0.05) {
            return regressionValue;
        } else {
            return 0;
        }
    }

    /**
     * This method is used for preprocessing the raw data from benchmark results to make sure the data is ready to be fed into the regression-detection process.
     * @param benchmarkResult represents the file path of the benchmark result.
     * @param keyWord represents the metric that will be extracted from the benchmark file.
     * @return the processed data which is ready to be fed into two-sample T-test algorithm.
     * @throws Exception if there's error occurred reading the benchmark result.
     */
    public static double[] preProcess(String benchmarkResult, String keyWord) throws Exception {
        IonList rawData;
        IonStruct benchmarkResultStruct = readHelper(benchmarkResult);
        if (keyWord.equals(SPEED)) {
            rawData = (IonList)((IonStruct) benchmarkResultStruct.get(PRIMARY_METRIC)).get(RAW_DATA);
        } else {
            IonStruct secondaryMetricStruct = (IonStruct) benchmarkResultStruct.get(SECONDARY_METRIC);
            rawData = (IonList) ((IonStruct) secondaryMetricStruct.get(keyWord)).get(RAW_DATA);
        }
        double[] data = rawData.stream().flatMapToDouble(element -> toDouble((IonList)element)).toArray();
        double[] processedData = removeOutliers(data);
        return processedData;
    }

    /**
     * Using Interquartile range method filtering out the outliers to make sure the raw data collection is normally distributed.
     * @param data represents the raw data from the same benchmarking process but different iterations.
     * @return the pre-processed data array without outlier.
     */
    public static double[] removeOutliers(double[] data) {
        Percentile percentile = new Percentile();
        double q1 = percentile.evaluate(data, 25.0);
        double q3 = percentile.evaluate(data, 75.0);
        double iqr = q3 - q1;

        double lowerBound = q1 - 1.5 * iqr;
        double upperBound = q3 + 1.5 * iqr;

        List<Double> filteredData = new ArrayList<>();
        for (double value : data) {
            if (value >= lowerBound && value <= upperBound) {
                filteredData.add(value);
            }
        }
        return filteredData.stream().mapToDouble(d -> d).toArray();
    }

    /**
     * Converting IonList to DoubleStream.
     * @param data represents the input IonList.
     * @return the converted DoubleStream.
     */
    public static DoubleStream toDouble(IonList data){
        return data.stream().mapToDouble(value -> Double.parseDouble(value.toString()));
    }

    /**
     * This is a helper method which create a IonReader for benchmark result and extract the IonStruct which contain parameters or scores information.
     *
     * @param benchmarkResultFilePath is the path of benchmark result.
     * @return an Ion Struct which contains information of parameters using during the benchmark process or scores.
     * @throws Exception if error occurs when reading Ion Data.
     */
    private static IonStruct readHelper(String benchmarkResultFilePath) throws Exception {
        try (IonReader reader = IonReaderBuilder.standard().build(new BufferedInputStream(new FileInputStream(benchmarkResultFilePath)))) {
            reader.next();
            if (reader.getType().equals(IonType.LIST)) {
                reader.stepIn();
                reader.next();
                if (reader.getType().equals(IonType.STRUCT)) {
                    IonDatagram benchmarkResultDatagram = LOADER.load(reader);
                    IonStruct benchmarkResult = (IonStruct) benchmarkResultDatagram.get(0);
                    return benchmarkResult;
                }
            }
            throw new IllegalStateException("The content of benchmark result is not supported.");
        }
    }
}