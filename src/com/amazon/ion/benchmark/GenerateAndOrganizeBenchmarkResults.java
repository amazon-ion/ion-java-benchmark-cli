package com.amazon.ion.benchmark;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

public class GenerateAndOrganizeBenchmarkResults {

    final public static List<String> BENCHMARK_OPTION_COMBINATIONS = Arrays.asList(
        "java -jar target/ion-java-benchmark-cli-0.0.1-SNAPSHOT-jar-with-dependencies.jar read --api dom --results-format ion ",
        "java -jar target/ion-java-benchmark-cli-0.0.1-SNAPSHOT-jar-with-dependencies.jar read --api streaming --results-format ion ",
        "java -jar target/ion-java-benchmark-cli-0.0.1-SNAPSHOT-jar-with-dependencies.jar write --api streaming --results-format ion ",
        "java -jar target/ion-java-benchmark-cli-0.0.1-SNAPSHOT-jar-with-dependencies.jar read --api streaming --format json --results-format ion ",
        "java -jar target/ion-java-benchmark-cli-0.0.1-SNAPSHOT-jar-with-dependencies.jar read --api dom --format json --results-format ion ",
        "java -jar target/ion-java-benchmark-cli-0.0.1-SNAPSHOT-jar-with-dependencies.jar write --api streaming --format json --results-format ion ");
    final private static String MAKE_DIRECTORY = "mkdir -p ";
    final private static String PREVIOUS_FILE = "previous.ion";
    final private static String NEW_FILE = "new.ion";

    /**
     * Execute ion-java-benchmark command with different options combinations and save the benchmark results generated by the same ion-java-benchmark invoke into the same directory.
     * One final directory which contains all directories from different ion-java-benchmark invokes will be generated under the specific file path.
     * @param optionsMap is the hash map which generated by the command line parser which match the option name and its value appropriately.
     * @throws IOException if errors occur during the executing command line process.
     */
    public static void generateAndSaveBenchMarkResults(Map<String, Object> optionsMap) throws IOException {
        String testDataDirectory = optionsMap.get("--test-ion-data").toString();
        String finalResultDirectory = optionsMap.get("<output_file>").toString();
        String fileName = PREVIOUS_FILE;
        String makeFinalDirectoryCommand = MAKE_DIRECTORY + finalResultDirectory;
        String subDirectoryName;
        // Create the directory that contains all results from different ion-java-benchmark invokes
        Process createFinalResultDirectory = Runtime.getRuntime().exec(makeFinalDirectoryCommand);

        File[] files = new File(testDataDirectory).listFiles();
        for (File testData : files) {
            for (String benchmarkOptionCombination : BENCHMARK_OPTION_COMBINATIONS) {
                // Use ion-java-benchmark as a start point to construct directory name which gives user a better idea which benchmark results would be contained under this directory.
                subDirectoryName = "/" + benchmarkOptionCombination.replace("java -jar target/ion-java-benchmark-cli-0.0.1-SNAPSHOT-jar-with-dependencies.jar", "ion-java-benchmark").replace("--results-format ion ","").replace(" ", "_") + testData.getName();
                Process makeSubDirectory = Runtime.getRuntime().exec(makeFinalDirectoryCommand + subDirectoryName);
                // When generating benchmark results for ion-java from the new commit, all benchmark results will be named as 'new.ion'.
                File fileCheck = new File(finalResultDirectory + subDirectoryName + "/" + fileName);
                if (fileCheck.exists()) {
                    fileName = NEW_FILE;
                }
                // Execute ion-java-benchmark invoke.
                String commandLine = benchmarkOptionCombination + "--results-file " +  finalResultDirectory + subDirectoryName + "/" + fileName + " " + testData.getAbsolutePath();
                Process process = Runtime.getRuntime().exec(commandLine);
                printExecuteProcess(process);
            }
        }
    }

    /**
     * Print the executing process of the specific command line.
     * @param process is the process that executing the specific command line.
     * @throws IOException if error occurs when reading executing process.
     */
    private static void printExecuteProcess(Process process) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }
    }
}